# 리스트

### 순차리스트

-  배열을 기반으로 구현된 리스트. 데이터의 물리적 순서와 논리적 순서 동일
- 배열의 인덱스를 이용해 원하는 위치의 데이터에 접근 가능
- 연산
  - 삽입연산
    - 삽입 위치 다음의 항목들을 이동해야 함
  - 삭제연산
    - 삭제 위치 다음의 항목들을 이동해야 함
- 원소의 개수가 많고, 삽입/삭제 연산이 빈번하게 일어날-수록 작업에 소요되는 시간이 크게 증가
- 배열의 크기가 정해져 있는 경우,  실제로 사용될 메모리보다 크게 할당하여 메모리의 낭비를 초래할 수 있고, 반대로 할당된 메모리 보다 많은 자료를 사용하여 새롭게 배열을 만들어 작업 해야하는 경우가 발생할 수도 있음



### 연결리스트

- 메모리의 동적할당을 기반으로 구현된 리스트
- 자료의 논리적 순서와 메모리 상의 물리적 순서가 일치하지 않음

- 자료구조의 크기를 동적으로 조정할 수 있어, 메모리의 효율적 사용 가능
- 기본 구조
  - 노드
    - 연결리스트에서 하나의 원소에 필요한 데이터를 갖고 있는 자료 단위
    - 구성요소
      - 데이터 필드: 원소의 값 저장, 저장할 원소의 종류나 크기에 따라 구조를 정의하여 사용
      - 링크필드: 다음 노드의 주소를 저장하는 자료구조
  - 헤드
    - 리스트의 처음 노드를 가리키는 레퍼런스
    - 헤드를 가지고 있으면 모든 노드를 갖고 있는 것
  - NULL로 끝나는 노드가 마지막 노드

- 단순 연결 리스트의 삽입 연산

  - 첫번째 노드로 삽입하는 알고리즘(가장 중요)

    ```java
    addtoFirst(L, i)				// 리스트 L, 원소 i
    		new <- createNode();	// 새로운 노드 생성
    		new.data = i;			// 데이터 필드 작성
    		new.link = L;			// 링크 필드 작성
    		L = new;				// 리스트의 처음으로 지정
    end addtoFirst()
    ```

  - 가운데나 마지막 노드로 삽입하는 알고리즘은 복잡해서 별로 사용할 일 없음

    

### 이중 연결 리스트(Doubly Linked List)

- 양쪽 방향으로 순회할 수 있도록 노드를 연결한 리스트
- 두 개의 링크 필드와 한 개의 데이터 필드로 구성
- **선행(이전) 노드의 탐색이 수월하도록 링크 필드를 하나 더 준 것**

